{"blocks":[{"data":{},"depth":0,"entityRanges":[],"inlineStyleRanges":[],"key":"66rqv","text":"In this part we will walk through writing Bresenhamâ€™s line drawing algorithm from scratch. The algorithm's purpose is to determine which pixels in (here two-dimensional) raster should be selected to form a straight line between two points.","type":"unstyled"},{"data":{},"depth":0,"entityRanges":[],"inlineStyleRanges":[],"key":"eidgg","text":"","type":"unstyled"},{"data":{},"depth":0,"entityRanges":[],"inlineStyleRanges":[],"key":"4on0g","text":"We will be drawing three lines with, each with a different slope (because that will let us clearly see the mistakes that the first version of algorithm makes.)","type":"unstyled"},{"data":{},"depth":0,"entityRanges":[],"inlineStyleRanges":[],"key":"5sjcj","text":"","type":"unstyled"},{"data":{},"depth":0,"entityRanges":[],"inlineStyleRanges":[],"key":"fujai","text":"Our first try  uses an arbitrary constant (fraction of the whole distance) and colors the pixels between start and end points starting with the one at position of start point and then at each step it will add to that starting point the increasing fraction of what will add up to the ending point. The final position is then rounded down. You can see the result in 'rendered_images/<timestamp>/lines1.png'. The problem with this approach is the choice of the constant - the picture will look all right for appropriate constant, but we still have to calculate it.","type":"unstyled"},{"data":{},"depth":0,"entityRanges":[],"inlineStyleRanges":[],"key":"ef104","text":"","type":"unstyled"},{"data":{},"depth":0,"entityRanges":[],"inlineStyleRanges":[],"key":"aa9it","text":"In the secord try we try to calculate the constant with the help of the number of pixels that will be drawn in one dimension. We then calculate the constant (which still represents increasing fraction of the line) as the length from start divided by length of line in x dimension. The pixel's y position is just a rewritten form of position y calculation from our first try. The third line should rewrite the first one (white), but the one problem with this try is that it is not working symmetricaly.","type":"unstyled"},{"data":{},"depth":0,"entityRanges":[],"inlineStyleRanges":[],"key":"eiboi","text":"","type":"unstyled"},{"data":{},"depth":0,"entityRanges":[],"inlineStyleRanges":[],"key":"4m2o4","text":"The third attempt should solve this. We swap x and y position of the start and the end, so that we can calculate the constant according to the dimension with bigger length. In other words - we iterate over the longer dimension because we know that if that dimension has length n then exactly n pixels will be drawn when traveling from start to end. The shorter dimension's pixels will be calculated accordingly.","type":"unstyled"},{"data":{},"depth":0,"entityRanges":[],"inlineStyleRanges":[],"key":"3ffd1","text":"Then we swap the start and the end so the start is always smaller than the end.","type":"unstyled"},{"data":{},"depth":0,"entityRanges":[],"inlineStyleRanges":[],"key":"bn7ah","text":"The loop stays almost exactly the same, just at the end when we are about to color the pixel, we check if we switched x and y positions and if so then we switch pixel's x and y.","type":"unstyled"},{"data":{},"depth":0,"entityRanges":[],"inlineStyleRanges":[],"key":"f5vh0","text":"","type":"unstyled"},{"data":{},"depth":0,"entityRanges":[],"inlineStyleRanges":[],"key":"99avk","text":"Fourth attempt is an optimization - we remove calculation from the loop and instead calculate \"steepness\" of line. Then in the loop (we still loop over the longer dimension of the line) we accumulate error - we start with 0 and each time we add pixel we increase the error by the steepness. Then if the error is bigger than 0.5 we increase (or decrease if line is descending in y dimension) pixel's y position by 1 and decrease error by one. In other words - we color pixels from the line start, increase x position by one each time, but increase the y position only if the incrementally added steepness increased (in total) by more than one (pixel).","type":"unstyled"},{"data":{},"depth":0,"entityRanges":[],"inlineStyleRanges":[],"key":"vsnq","text":"","type":"unstyled"}],"entityMap":{}}